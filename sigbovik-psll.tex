\documentclass[aip,jcp,reprint]{revtex4-1}

\usepackage[utf8]{inputenc} % Unicode input encoding
\usepackage[T1]{fontenc} % Font encoding

\usepackage[utopia]{mathdesign}
\usepackage{erewhon}

\usepackage{inconsolata}
\usepackage[english]{babel} % English linebrakes, hyphenation etc.
\usepackage[%
	tracking=true,kerning=true,spacing=true,%
	stretch=10,shrink=10,%
	factor=1100,%
	]{microtype}
\microtypecontext{spacing=nonfrench}
	
\usepackage{graphicx}% Include figure files
\graphicspath{ {./img/} }

\usepackage{multirow}

\usepackage{csquotes}
\usepackage{parskip} % Change paragraph formatting parindent = 0, parskip > 0
\usepackage{bm}% bold math
\usepackage{mathtools}
\usepackage{xspace}
\usepackage{xcolor}

\DeclareMathAlphabet{\mathoms}{OMS}{cmsy}{m}{n}
\DeclareMathOperator{\bigO}{\ensuremath{\mathoms{O}}}

\usepackage{lipsum}
\usepackage{nopageno}
\usepackage{enumitem}
\setlist{nosep}

\raggedbottom
%\flushbottom

% Placeholders
\newcommand\plcite{{\color{red}\textbf{[???]}}\xspace}
\newcommand\plinfo{{\color[rgb]{0.929,0.694,0.125}\textbf{[info]}}\xspace}
\let\tt\texttt
\newcommand\psll{\texttt{psll}\xspace}

\usepackage{color}

\definecolor{lines_blue}{rgb}{0, 0.4470, 0.7410}
\definecolor{lines_red}{rgb}{0.8500, 0.3250, 0.0980}
\definecolor{lines_yellow}{rgb}{0.9290, 0.6940, 0.1250}
\definecolor{lines_purple}{rgb}{0.4940, 0.1840, 0.5560}
\definecolor{lines_green}{rgb}{0.4660, 0.6740, 0.1880}
\definecolor{lines_cyan}{rgb}{0.3010, 0.7450, 0.9330}
\definecolor{lines_burgundy}{rgb}{0.6350, 0.0780, 0.1840}

% Hyperref
\PassOptionsToPackage{hyphens}{url}
% Hyper reference setup
\usepackage[%
bookmarks=false, hypertexnames=false,%
colorlinks, allcolors={green}, citecolor={blue}, urlcolor={red}, %
unicode, % Encode pdf as unicode
breaklinks=true, % Allow links to break lines
hyperfootnotes=false % Dont link footnotes (This does not work very well)
]{hyperref}%


\usepackage{listings}
% " , / , [ and ] keywords don't play nicely with other syntax
\lstdefinelanguage{psll} {%
otherkeywords={+,!,=,<=>,*,-,^,\#,?,_},
morekeywords={out,chr,arg,set,do,loop},
morekeywords={[2]def,range,len},
sensitive=false,
morecomment=[l]{//},%
morestring=[b]",%
}

\lstset{
  aboveskip=3mm,belowskip=3mm,%
  columns=flexible,%
  basicstyle={\small\ttfamily},%
  numberstyle=\small\normalfont\ttfamily\color{black!25!white},%
  keywordstyle=\color{lines_blue},%
  keywordstyle={[2]\color{orange}},%
  commentstyle=\color{lines_green},%
  stringstyle=\color{lines_purple},%
  breaklines=false,
  numbersep=5pt,
  tabsize=4,
}

\newcommand{\ilpsll}[1]{\lstinline[language=psll,columns=flexible]{#1}}
\newcommand{\ilruby}[1]{\lstinline[language=ruby,columns=flexible]{#1}}

\begin{document}
\preprint{AIP/123-QED}

\title{Design and implementation of \psll\ -- Lisp-like programming language which compiles to Pyramid Scheme}

\def\crl{Department of Chemistry, University of Oxford, Chemistry Research Laboratory, Oxford OX1 3TA, U.K.}
\def\samueli{UCLA Samueli School of Engineering, University of California, Los Angeles, 7400 Boelter Hall, Los Angeles, CA 90095, United States}
\author{Marcin~Konowalczyk}\email{marcin.konow@lczyk.xyz}\affiliation{\crl}\affiliation{\samueli}

\date{\today}

\begin{abstract}

\lipsum[1]
\end{abstract}

\keywords{syntax tree; pyramid scheme; lisp; compilation}

\maketitle

\section{Introduction}

Pyramid Scheme is a variant of the Scheme dialect of Lisp, designed by Conor O'Brien, in the early 2017 (date of the earliest commit to the GitHub repository).\cite{pyra_git} It is a turing-complete esoteric programming language (esolang)\cite{pyra_esolang} which uses tree-like, as opposed to a linear code structure. Pyramid scheme is a true outlier in the contemporary computing scene. Whereas most languages / frameworks build on top of the existing infrastructure to create \enquote{the stack} of software,\cite{cantrill2017} pyramid scheme aims to remove unnecessary abstractions. Compilers make use of an intermediate representation of the language in the form of an abstract syntax tree (AST).\cite{cooper2011} Pyramid scheme removes this, clearly unnecessary, abstraction and represents the computation in the form of a literal syntax tree (LST) of ascii-art pyramidal constructs.

Pyramid scheme is supported by the \enquote{Try It Online!} repository of inline interpreters,\cite{tio} and, like many other esolangs, has been featured in many Code Golfing challenges.\cite{golf_se} In ancient Egypt, pyramids were constructed as the resting places of deceased pharaos, containing not only their mummified remains but also an assortment of keywords and/or type literals the pharaoh need in the afterlife. The authors don't suppose the association accidental.

\subsection{Implementation of Pyramid Scheme}

Ruby Dictionary Memory (RDM)

\cite{dbeaz2018}

\lipsum[1-5]

\section{Language description}
\subsection{Bracket structure}

\subsection{Syntactic sugar}\label{sec:sugar}
The above specification is, in principle, enough to create fully fully functional PS programs. Certain tasks are, however, still rather cumbersome. This section outlines these cases, as well as syntactic sugar constructs introduced to \psll to alleviate them. All of these are implemented as local (or semi-local) expansion macros, as described in Section~\ref{sec:macros}. Despite authors best efforts, this introduces some sharp edges into the language (see Section~\ref{sec:sharp_edges}).

\textbf{Implicit bracket expansion} Each bracket must have exactly three elements. For small expressions this is almost always the case, but becomes problematic for larger, flow-control and loop structures where each such expression can contain an arbitrarily large number of sub-expressions (see \plinfo for an example of such expression). Hence a bracket containing $>2$ other brackets gets expanded as follows:
\begin{lstlisting}[language=psll,aboveskip=3pt,belowskip=-2pt]
( (out 1) (out 2) (out 3) (out 4) (out 5) )
\end{lstlisting}
is interpreted as:
\begin{lstlisting}[language=psll,aboveskip=3pt,belowskip=-2pt]
( (((out 1) (out 2))  ((out 3) (out 4)))  (out 5) )
\end{lstlisting}
Each neighbouring pair or elements of the parent gets put together into a bracket, until the length of the parent is less than 2. This results in a (literal) balanced binary tree in the final PS code, and so for a parent bracket of $N$ sub-expressions will result in a tree of height $\bigO\left(\log_2\left(N\right)\right)$.

\textbf{String literals} Single characters can be created in RDM with the \tt{chr} keyword (Ruby \tt{.to\textunderscore{}i.chr}). It is also possible to construct longer strings in RDM since Ruby's \enquote{\tt{+}} sign overloads string concatenation. The string \textit{\enquote{hello}} is therefore:
\begin{lstlisting}[language=psll,aboveskip=3pt,belowskip=-2pt]
(+ (+ (+ (+ (chr 72) (chr 101)) (chr 108))
	(chr 108)) (chr 111))
\end{lstlisting}
\psll introduces string literals, such that \ilpsll{(set s "hello")} expands into the above code. Note that this is a very left-child heavy tree. To balance it, the above string could also be made by recursively concatenating its binary split:
\begin{lstlisting}[language=psll,aboveskip=3pt,belowskip=-2pt]
(+ (+ (chr 72) (chr 101))
	(+ (chr 108) (+ (chr 108)) (chr 111)))
\end{lstlisting}
such that $\textit{\enquote{hello}} = \textit{\enquote{he}} + \textit{\enquote{llo}} = \left(\textit{\enquote{h}} + \textit{\enquote{e}}\,\right) + \left(\textit{\enquote{l}} + \textit{\enquote{lo}}\,\right) = \dots$.

\textbf{Array literals}

\textbf{Rolling sum and product}

\textbf{\tt{def} keyword}

Semi-local

\subsection{Sharp edges}\label{sec:sharp_edges}
As mentioned at the beginning of Section~\ref{sec:sugar}, the introduction of syntactic sugar into \psll introduces some edge cases which one ought to watch out for.

\textbf{Underscore keyword}
\_

\textbf{Escape characters}
Because " is used for strings, and [ ] for arrays...

\section{Compiler}
\subsection{Abstract syntax tree}
\subsection{Local macro expansion}\label{sec:macros}
\subsection{Optimisation}

\section{Example programs}
\subsection{Pseudorandom number generation}
\subsection{Bubble sort}
\subsection{Chess engine}

\begin{lstlisting}[language=psll,frame=tb,numbers=left,aboveskip=3mm,belowskip=3mm]
(set a 0) // Flip-flop
(set N 10) (set j 0) // N of iteration and loop counter
(loop (! (= j N)) (
    // Do some work...
    (out j (chr 32)) // Print j and space
    (out a (chr 10)) // Print a and newline
    (set a (! a)) // Flip a
(set j (+ j 1))
)) (set test "hi")
\end{lstlisting}

\begin{lstlisting}[language=psll,frame=tb,numbers=left,aboveskip=3mm,belowskip=3mm]
  (set newline "\n")
  (set nil (arg 999))
  
  // Array to be sorted
  (set a [3 1 4 1 5 9 2 6 5 3 5])
  
  // Get array length
  // (len a N)
  
  ( (set N 0) (loop (! (= (arg a N) nil)) (set N (+ N 1))) )
  
  (set N 0) // Pointer into the array
  (loop (! (= (arg a N) nil)) (set N (+ N 1))) // Increment pointer until goes off the end
  
  (def sup "hello")
  // Bubble sort the array
  (do again (
      (set again 0)
      (set n 0) // Position pointer
      (loop (! (! (<=> n (- N 1)))) ( // Go through all the pairs
          (set this (arg a n))
          (set next (arg a (+ n 1)))
  
          // This and next need swapping
          (set swap (! (<=> (<=> this next) -1)))
          (? swap (
              (set again 1) // Will need to go through the list again
              (set b []) // Start b as an empty array
              
              // Add prefix of a
              (set l 0)
              (loop (= (<=> l n) -1) (
                  (set b (+ b (- ((arg a l) nil) (nil nil))))
              (set l (+ l 1))
              ))
  
              // Add two elements, swapped
              (set b (+ b (- ((arg a (+ n 1)) nil) (nil nil))))
              (set b (+ b (- ((arg a (+ n 0)) nil) (nil nil))))
  
              // Add suffix of a
              (set l (+ n 2))
              (loop (= (<=> l N) -1) (
                  (set b (+ b (- ((arg a l) nil) (nil nil))))
              (set l (+ l 1))
              ))
              (set a b)
          ))
      (set n (+ n 1)) // Increment position pointer
      ))
      (out (* a ",") newline) // Print b + newline
  ))
\end{lstlisting}

\section{Conclusions and outlook}
Program in Pyramid Scheme! Teach your friends! Have them teach \emph{their} friends! Then have those friends teach \emph{their} friends!

- Joined pyramids

\lipsum[11-15]
\ilpsll{(chr 10)}
\section*{Links}

\begin{itemize}
\item psll git
\item pyramid scheme
\item TiO hello world in ps
\item Esolang page?
\item Code Golf page
\end{itemize}

\section*{Acknowledgements}
%I would like to thank Blain Rodgers and Samuel Hutton for proofreading and their helpful comments on the manuscript.
 
\nocite{*}
\bibliographystyle{unsrt}
\bibliography{sigbovik-psll.bib} %< bib file name

\end{document}